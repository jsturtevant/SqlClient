// Generated by `wit-bindgen` 0.32.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace ImportsWorld.wit.imports.wasi.sockets.v0_2_1;

public interface IUdp {

    /**
    * A received datagram.
    */

    public class IncomingDatagram {
        public readonly byte[] data;
        public readonly global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress remoteAddress;

        public IncomingDatagram(byte[] data, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress remoteAddress) {
            this.data = data;
            this.remoteAddress = remoteAddress;
        }
    }

    /**
    * A datagram to be sent out.
    */

    public class OutgoingDatagram {
        public readonly byte[] data;
        public readonly global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress? remoteAddress;

        public OutgoingDatagram(byte[] data, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress? remoteAddress) {
            this.data = data;
            this.remoteAddress = remoteAddress;
        }
    }

    /**
    * A UDP socket handle.
    */

    public class UdpSocket: IDisposable {
        internal int Handle { get; set; }

        public readonly record struct THandle(int Handle);

        public UdpSocket(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[resource-drop]udp-socket"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class StartBindWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.start-bind"), WasmImportLinkage]
            internal static extern void wasmImportStartBind(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13, nint p14);

        }

        public   unsafe void StartBind(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Network network, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress localAddress)
        {
            var handle = this.Handle;
            var handle0 = network.Handle;

            int lowered;
            int lowered4;
            int lowered5;
            int lowered6;
            int lowered7;
            int lowered8;
            int lowered9;
            int lowered10;
            int lowered11;
            int lowered12;
            int lowered13;
            int lowered14;

            switch (localAddress.Tag) {
                case 0: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress payload = localAddress.AsIpv4;

                    lowered = 0;
                    lowered4 = payload.port;
                    lowered5 = payload.address.Item1;
                    lowered6 = payload.address.Item2;
                    lowered7 = payload.address.Item3;
                    lowered8 = payload.address.Item4;
                    lowered9 = 0;
                    lowered10 = 0;
                    lowered11 = 0;
                    lowered12 = 0;
                    lowered13 = 0;
                    lowered14 = 0;

                    break;
                }
                case 1: {
                    global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress payload3 = localAddress.AsIpv6;

                    lowered = 1;
                    lowered4 = payload3.port;
                    lowered5 = unchecked((int)(payload3.flowInfo));
                    lowered6 = payload3.address.Item1;
                    lowered7 = payload3.address.Item2;
                    lowered8 = payload3.address.Item3;
                    lowered9 = payload3.address.Item4;
                    lowered10 = payload3.address.Item5;
                    lowered11 = payload3.address.Item6;
                    lowered12 = payload3.address.Item7;
                    lowered13 = payload3.address.Item8;
                    lowered14 = unchecked((int)(payload3.scopeId));

                    break;
                }

                default: throw new ArgumentException($"invalid discriminant: {localAddress}");
            }

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                StartBindWasmInterop.wasmImportStartBind(handle, handle0, lowered, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, lowered14, ptr);

                Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(new global::ImportsWorld.None());
                        break;
                    }
                    case 1: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class FinishBindWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.finish-bind"), WasmImportLinkage]
            internal static extern void wasmImportFinishBind(int p0, nint p1);

        }

        public   unsafe void FinishBind()
        {
            var handle = this.Handle;

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                FinishBindWasmInterop.wasmImportFinishBind(handle, ptr);

                Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(new global::ImportsWorld.None());
                        break;
                    }
                    case 1: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class StreamWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.stream"), WasmImportLinkage]
            internal static extern void wasmImportStream(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13, nint p14);

        }

        public   unsafe (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream) Stream(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress? remoteAddress)
        {
            var handle = this.Handle;

            int lowered20;
            int lowered21;
            int lowered22;
            int lowered23;
            int lowered24;
            int lowered25;
            int lowered26;
            int lowered27;
            int lowered28;
            int lowered29;
            int lowered30;
            int lowered31;
            int lowered32;

            if (remoteAddress != null) {
                var payload2 = (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress) remoteAddress;

                int lowered;
                int lowered9;
                int lowered10;
                int lowered11;
                int lowered12;
                int lowered13;
                int lowered14;
                int lowered15;
                int lowered16;
                int lowered17;
                int lowered18;
                int lowered19;

                switch (payload2.Tag) {
                    case 0: {
                        global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress payload5 = payload2.AsIpv4;

                        lowered = 0;
                        lowered9 = payload5.port;
                        lowered10 = payload5.address.Item1;
                        lowered11 = payload5.address.Item2;
                        lowered12 = payload5.address.Item3;
                        lowered13 = payload5.address.Item4;
                        lowered14 = 0;
                        lowered15 = 0;
                        lowered16 = 0;
                        lowered17 = 0;
                        lowered18 = 0;
                        lowered19 = 0;

                        break;
                    }
                    case 1: {
                        global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress payload8 = payload2.AsIpv6;

                        lowered = 1;
                        lowered9 = payload8.port;
                        lowered10 = unchecked((int)(payload8.flowInfo));
                        lowered11 = payload8.address.Item1;
                        lowered12 = payload8.address.Item2;
                        lowered13 = payload8.address.Item3;
                        lowered14 = payload8.address.Item4;
                        lowered15 = payload8.address.Item5;
                        lowered16 = payload8.address.Item6;
                        lowered17 = payload8.address.Item7;
                        lowered18 = payload8.address.Item8;
                        lowered19 = unchecked((int)(payload8.scopeId));

                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {payload2}");
                }

                lowered20 = 1;
                lowered21 = lowered;
                lowered22 = lowered9;
                lowered23 = lowered10;
                lowered24 = lowered11;
                lowered25 = lowered12;
                lowered26 = lowered13;
                lowered27 = lowered14;
                lowered28 = lowered15;
                lowered29 = lowered16;
                lowered30 = lowered17;
                lowered31 = lowered18;
                lowered32 = lowered19;

            } else {

                lowered20 = 0;
                lowered21 = 0;
                lowered22 = 0;
                lowered23 = 0;
                lowered24 = 0;
                lowered25 = 0;
                lowered26 = 0;
                lowered27 = 0;
                lowered28 = 0;
                lowered29 = 0;
                lowered30 = 0;
                lowered31 = 0;
                lowered32 = 0;

            }

            var retArea = new uint[3];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                StreamWasmInterop.wasmImportStream(handle, lowered20, lowered21, lowered22, lowered23, lowered24, lowered25, lowered26, lowered27, lowered28, lowered29, lowered30, lowered31, lowered32, ptr);

                Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        var resource = new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));
                        var resource35 = new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4))));

                        lifted = Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok((resource, resource35
                        ));
                        break;
                    }
                    case 1: {

                        lifted = Result<(global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagramStream, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagramStream), global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class LocalAddressWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.local-address"), WasmImportLinkage]
            internal static extern void wasmImportLocalAddress(int p0, nint p1);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress LocalAddress()
        {
            var handle = this.Handle;

            var retArea = new uint[9];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                LocalAddressWasmInterop.wasmImportLocalAddress(handle, ptr);

                Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted6;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv4(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress (
                                ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), (((byte)new Span<byte>((void*)(ptr + 10), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 11), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 12), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 13), 1)[0])
                                )));
                                break;
                            }
                            case 1: {

                                lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv6(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress (
                                ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)))), (((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 16), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 18), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 20), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 22), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 24), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 26), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 28), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 30), 2)))
                                ), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 32), 4))))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(lifted);
                        break;
                    }
                    case 1: {

                        lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted6.IsOk) {
                    var tmp = lifted6.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted6.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class RemoteAddressWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.remote-address"), WasmImportLinkage]
            internal static extern void wasmImportRemoteAddress(int p0, nint p1);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress RemoteAddress()
        {
            var handle = this.Handle;

            var retArea = new uint[9];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                RemoteAddressWasmInterop.wasmImportRemoteAddress(handle, ptr);

                Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted6;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv4(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress (
                                ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), (((byte)new Span<byte>((void*)(ptr + 10), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 11), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 12), 1)[0]), ((byte)new Span<byte>((void*)(ptr + 13), 1)[0])
                                )));
                                break;
                            }
                            case 1: {

                                lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv6(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress (
                                ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 8), 2))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)))), (((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 16), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 18), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 20), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 22), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 24), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 26), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 28), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(ptr + 30), 2)))
                                ), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 32), 4))))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(lifted);
                        break;
                    }
                    case 1: {

                        lifted6 = Result<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted6.IsOk) {
                    var tmp = lifted6.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted6.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class AddressFamilyWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.address-family"), WasmImportLinkage]
            internal static extern int wasmImportAddressFamily(int p0);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpAddressFamily AddressFamily()
        {
            var handle = this.Handle;
            var result =  AddressFamilyWasmInterop.wasmImportAddressFamily(handle);
            return (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpAddressFamily)result;

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class UnicastHopLimitWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.unicast-hop-limit"), WasmImportLinkage]
            internal static extern void wasmImportUnicastHopLimit(int p0, nint p1);

        }

        public   unsafe byte UnicastHopLimit()
        {
            var handle = this.Handle;

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                UnicastHopLimitWasmInterop.wasmImportUnicastHopLimit(handle, ptr);

                Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(((byte)new Span<byte>((void*)(ptr + 1), 1)[0]));
                        break;
                    }
                    case 1: {

                        lifted = Result<byte, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SetUnicastHopLimitWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.set-unicast-hop-limit"), WasmImportLinkage]
            internal static extern void wasmImportSetUnicastHopLimit(int p0, int p1, nint p2);

        }

        public   unsafe void SetUnicastHopLimit(byte value)
        {
            var handle = this.Handle;

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SetUnicastHopLimitWasmInterop.wasmImportSetUnicastHopLimit(handle, value, ptr);

                Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(new global::ImportsWorld.None());
                        break;
                    }
                    case 1: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class ReceiveBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.receive-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportReceiveBufferSize(int p0, nint p1);

        }

        public   unsafe ulong ReceiveBufferSize()
        {
            var handle = this.Handle;

            var retArea = new ulong[2];
            fixed (ulong* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ReceiveBufferSizeWasmInterop.wasmImportReceiveBufferSize(handle, ptr);

                Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                        break;
                    }
                    case 1: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SetReceiveBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.set-receive-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSetReceiveBufferSize(int p0, long p1, nint p2);

        }

        public   unsafe void SetReceiveBufferSize(ulong value)
        {
            var handle = this.Handle;

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SetReceiveBufferSizeWasmInterop.wasmImportSetReceiveBufferSize(handle, unchecked((long)(value)), ptr);

                Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(new global::ImportsWorld.None());
                        break;
                    }
                    case 1: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SendBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.send-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSendBufferSize(int p0, nint p1);

        }

        public   unsafe ulong SendBufferSize()
        {
            var handle = this.Handle;

            var retArea = new ulong[2];
            fixed (ulong* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SendBufferSizeWasmInterop.wasmImportSendBufferSize(handle, ptr);

                Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                        break;
                    }
                    case 1: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SetSendBufferSizeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.set-send-buffer-size"), WasmImportLinkage]
            internal static extern void wasmImportSetSendBufferSize(int p0, long p1, nint p2);

        }

        public   unsafe void SetSendBufferSize(ulong value)
        {
            var handle = this.Handle;

            var retArea = new byte[2];
            fixed (byte* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SetSendBufferSizeWasmInterop.wasmImportSetSendBufferSize(handle, unchecked((long)(value)), ptr);

                Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(new global::ImportsWorld.None());
                        break;
                    }
                    case 1: {

                        lifted = Result<None, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 1), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SubscribeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]udp-socket.subscribe"), WasmImportLinkage]
            internal static extern int wasmImportSubscribe(int p0);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable Subscribe()
        {
            var handle = this.Handle;
            var result =  SubscribeWasmInterop.wasmImportSubscribe(handle);
            var resource = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable.THandle(result));
            return resource;

            //TODO: free alloc handle (interopString) if exists
        }

    }

    public class IncomingDatagramStream: IDisposable {
        internal int Handle { get; set; }

        public readonly record struct THandle(int Handle);

        public IncomingDatagramStream(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[resource-drop]incoming-datagram-stream"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class ReceiveWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]incoming-datagram-stream.receive"), WasmImportLinkage]
            internal static extern void wasmImportReceive(int p0, long p1, nint p2);

        }

        public   unsafe List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram> Receive(ulong maxResults)
        {
            var handle = this.Handle;

            var retArea = new uint[3];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ReceiveWasmInterop.wasmImportReceive(handle, unchecked((long)(maxResults)), ptr);

                Result<List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram>, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted9;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        var array6 = new List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)));
                        for (int index = 0; index < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)); ++index) {
                            nint basePtr1 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)) + (index * 40);

                            var array = new byte[BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 4), 4))];
                            new Span<byte>((void*)(BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 0), 4))), BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 4), 4))).CopyTo(new Span<byte>(array));

                            global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress lifted;

                            switch (new Span<byte>((void*)(basePtr1 + 8), 1)[0]) {
                                case 0: {

                                    lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv4(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress (
                                    ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 12), 2))), (((byte)new Span<byte>((void*)(basePtr1 + 14), 1)[0]), ((byte)new Span<byte>((void*)(basePtr1 + 15), 1)[0]), ((byte)new Span<byte>((void*)(basePtr1 + 16), 1)[0]), ((byte)new Span<byte>((void*)(basePtr1 + 17), 1)[0])
                                    )));
                                    break;
                                }
                                case 1: {

                                    lifted = global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress.ipv6(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress (
                                    ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 12), 2))), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 16), 4)))), (((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 20), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 22), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 24), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 26), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 28), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 30), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 32), 2))), ((ushort)BitConverter.ToUInt16(new Span<byte>((void*)(basePtr1 + 34), 2)))
                                    ), unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 36), 4))))));
                                    break;
                                }

                                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(basePtr1 + 8), 1)[0]}");
                            }

                            array6.Add(new global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram (
                            array, lifted));
                        }

                        lifted9 = Result<List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram>, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(array6);
                        break;
                    }
                    case 1: {

                        lifted9 = Result<List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.IncomingDatagram>, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 4), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted9.IsOk) {
                    var tmp = lifted9.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted9.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SubscribeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]incoming-datagram-stream.subscribe"), WasmImportLinkage]
            internal static extern int wasmImportSubscribe(int p0);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable Subscribe()
        {
            var handle = this.Handle;
            var result =  SubscribeWasmInterop.wasmImportSubscribe(handle);
            var resource = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable.THandle(result));
            return resource;

            //TODO: free alloc handle (interopString) if exists
        }

    }

    public class OutgoingDatagramStream: IDisposable {
        internal int Handle { get; set; }

        public readonly record struct THandle(int Handle);

        public OutgoingDatagramStream(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[resource-drop]outgoing-datagram-stream"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class CheckSendWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]outgoing-datagram-stream.check-send"), WasmImportLinkage]
            internal static extern void wasmImportCheckSend(int p0, nint p1);

        }

        public   unsafe ulong CheckSend()
        {
            var handle = this.Handle;

            var retArea = new ulong[2];
            fixed (ulong* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                CheckSendWasmInterop.wasmImportCheckSend(handle, ptr);

                Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                        break;
                    }
                    case 1: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SendWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]outgoing-datagram-stream.send"), WasmImportLinkage]
            internal static extern void wasmImportSend(int p0, nint p1, int p2, nint p3);

        }

        public   unsafe ulong Send(List<global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagram> datagrams)
        {
            var handle = this.Handle;

            byte[] buffer11 = new byte[44 * datagrams.Count];
            var gcHandle = GCHandle.Alloc(buffer11, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < datagrams.Count; ++index) {
                global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.IUdp.OutgoingDatagram element = datagrams[index];
                int basePtr = (int)address + (index * 44);

                void* buffer = stackalloc byte[(element.data).Length];
                element.data.AsSpan<byte>().CopyTo(new Span<byte>(buffer, element.data.Length));
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 4), 4), unchecked((int)(element.data).Length));
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 0), 4), unchecked((int)(int)buffer));

                if (element.remoteAddress != null) {
                    var payload4 = (global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.IpSocketAddress) element.remoteAddress;
                    *(byte*)(basePtr + 8) = (byte)1;

                    switch (payload4.Tag) {
                        case 0: {
                            global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv4SocketAddress payload7 = payload4.AsIpv4;
                            *(byte*)(basePtr + 12) = (byte)0;
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 16), 2), (short)payload7.port);
                            *(byte*)(basePtr + 18) = (byte)payload7.address.Item1;
                            *(byte*)(basePtr + 19) = (byte)payload7.address.Item2;
                            *(byte*)(basePtr + 20) = (byte)payload7.address.Item3;
                            *(byte*)(basePtr + 21) = (byte)payload7.address.Item4;

                            break;
                        }
                        case 1: {
                            global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.Ipv6SocketAddress payload10 = payload4.AsIpv6;
                            *(byte*)(basePtr + 12) = (byte)1;
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 16), 2), (short)payload10.port);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 20), 4), unchecked((int)unchecked((int)(payload10.flowInfo))));
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 24), 2), (short)payload10.address.Item1);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 26), 2), (short)payload10.address.Item2);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 28), 2), (short)payload10.address.Item3);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 30), 2), (short)payload10.address.Item4);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 32), 2), (short)payload10.address.Item5);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 34), 2), (short)payload10.address.Item6);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 36), 2), (short)payload10.address.Item7);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 38), 2), (short)payload10.address.Item8);
                            BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 40), 4), unchecked((int)unchecked((int)(payload10.scopeId))));

                            break;
                        }

                        default: throw new ArgumentException($"invalid discriminant: {payload4}");
                    }

                } else {

                    *(byte*)(basePtr + 8) = (byte)0;

                }

            }

            var retArea = new ulong[2];
            fixed (ulong* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SendWasmInterop.wasmImportSend(handle, (int)address, datagrams.Count, ptr);

                Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.ok(unchecked((ulong)(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)))));
                        break;
                    }
                    case 1: {

                        lifted = Result<ulong, global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode>.err((global::ImportsWorld.wit.imports.wasi.sockets.v0_2_1.INetwork.ErrorCode)new Span<byte>((void*)(ptr + 8), 1)[0]);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SubscribeWasmInterop
        {
            [DllImport("wasi:sockets/udp@0.2.1", EntryPoint = "[method]outgoing-datagram-stream.subscribe"), WasmImportLinkage]
            internal static extern int wasmImportSubscribe(int p0);

        }

        public   unsafe global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable Subscribe()
        {
            var handle = this.Handle;
            var result =  SubscribeWasmInterop.wasmImportSubscribe(handle);
            var resource = new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable(new global::ImportsWorld.wit.imports.wasi.io.v0_2_1.IPoll.Pollable.THandle(result));
            return resource;

            //TODO: free alloc handle (interopString) if exists
        }

    }

}
